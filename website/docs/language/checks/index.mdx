---
page_title: Checks - Configuration Language
description: >-
  Check custom requirements for infrastructure to provide ongoing and continuous validation.
---

# Checks

-> **Note:** Check blocks are only available in Terraform v1.5.0 and later.

You can use `check` blocks to validate your infrastructure outside the usual resource lifecycle. Check blocks address a gap between post-apply and functional validation of infrastructure. Check blocks allow you to define [Custom Conditions](/terraform/language/expressions/custom-conditions) that execute on every Terraform plan or apply operation without affecting the overall status of the operation. They execute as the last step of a plan/apply, after the infrastructure has been planned/provisioned.

## Checks Syntax

A `check` block declares a check with a given local name, zero to one scoped [data sources](#scoped-data-sources), and one to many [assertions](#assertions).

The following example loads the Terraform website and validates it is returning the expected status code of 200.

```hcl
check "health_check" {
  data "http" "terraform_io" {
    url = "https://www.terraform.io"
  }

  assert {
    condition = data.http.terraform_io.status_code == 200
    error_message = "${data.http.terraform_io.url} returned an unhealthy status code"
  }
}
```

### Scoped Data Sources

A `check` block can optionally have a nested data source. This block behaves in the same way as normal/external [data sources](/terraform/language/data-sources), except it cannot be referenced from outside the enclosing check block. In addition, any errors or failures raised by the provider of the data source will be masked as warnings within the output and will not prevent the continued execution of the overall Terraform operation.

A scoped data source allows you to validate the status of a piece of infrastructure outside the usual Terraform resource lifecycle. In the example in the previous section, if the `terraform_io` data source fails to load we would simply receive a warning that the `http` block couldn't be loaded rather than the blocking error that would be raised if the data source was defined outside a check block.

Any data source from any provider can be used within a check block.

#### Meta-Arguments

Scoped data sources support the `depends_on` and `provider` [meta-arguments](/terraform/language/resources/syntax#meta-arguments), but do not support the `count`, `foreach`, or `lifecycle` arguments.

### Assertions

Each `check` block must have at least one, but potentially many, `assert` blocks. An `assert` block has a `condition` attribute and an `error_message` attribute, that match the definitions within [Custom Conditions](/terraform/language/expressions/custom-conditions).

Unlike other custom conditions, assertions do not affect the execution of the overall Terraform operation. A failed assertion will report a warning diagnostic without halting the ongoing operation. This is in contrast to other custom conditions, such as a resource postcondition, which will block future resources from being applied or planned.

Conditions within assertions can refer to any scoped data source within the enclosing check block, and can refer to any variables, resources, data sources, or module outputs within the current module.

Assertions are discussed more in detail within the [Custom Conditions](/terraform/language/expressions/custom-conditions#check-assertions) documentation.

### Meta-Arguments

In the initial release of checks, none of the traditional resource [meta-arguments](/terraform/language/resources/syntax#meta-arguments) are supported. We are interested to see how the community uses this new feature, so please file feedback with use-cases that would benefit from the introduction of any meta-arguments.

## Continuous Validation in Terraform Cloud

Terraform Cloud can automatically check whether checks in a workspaceâ€™s configuration continue to pass after Terraform provisions the infrastructure. Refer to [Continuous Validation](/terraform/cloud-docs/workspaces/health#continuous-validation) in the Terraform Cloud documentation for details.

## Choosing between Checks and other Custom Conditions

In many cases, resource or data source postconditions and check blocks can be used interchangeably to model similar validations. For example, compare the following HCL, which details the creation of a health check directly as a data source postcondition, to the check block implementation provided in the [Checks Syntax](#checks-syntax) section.

```hcl
data "http" "terraform_io" {
  url = "https://www.terraform.io"

  lifecycle {
    postcondition {
        condition = self.status_code == 200
        error_message = "${self.url} returned an unhealthy status code"
    }
  }
}
```

Both these implementations will validate that the status code is returned as expected during a plan or an apply operation. However, they differ in how they respond when the validation fails. The data source postcondition will fail and block the continued execution of any Terraform operation while the check block is permissive and will not interfere with the overall Terraform operation.

This means that recovering from a failure is impossible with a postcondition as Terraform will block any plan or apply operations as long as the postcondition is unsatisfied during the plan. This problem stems from the postcondition not being directly dependent on the Terraform configuration but instead on the complex interactions between multiple resources.

With this contrast in mind, check blocks should therefore be used to validate the status of the infrastructure as a whole compared to a postcondition which should provide a guarantee on a single resource based on that resource's configuration.
