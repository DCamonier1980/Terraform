---
page_title: Checks - Configuration Language
description: >-
  Check customized infrastructure requirements to provide ongoing and continuous verification.
---

# Checks

-> **Note:** Check blocks are only available in Terraform v1.5.0 and later.

The `check` block can validate your infrastructure outside the usual resource lifecycle. Check blocks address a gap between post-apply and functional validation of infrastructure. Check blocks allow you to define [custom conditions](/terraform/language/expressions/custom-conditions) that execute on every Terraform plan or apply operation without affecting the overall status of an operation. Check blocks execute as the last step of a plan or apply, after Terraform has planned or provisioned your infrastructure.

## Checks Syntax

You can declare a `check` block with a local name, zero-to-one scoped [data sources](#scoped-data-sources), and one-to-many [assertions](#assertions).

The following example loads the Terraform website and validates that it returns the expected status code of `200`.

```hcl
check "health_check" {
  data "http" "terraform_io" {
    url = "https://www.terraform.io"
  }

  assert {
    condition = data.http.terraform_io.status_code == 200
    error_message = "${data.http.terraform_io.url} returned an unhealthy status code"
  }
}
```

### Scoped Data Sources

You can use any data source from any provider as a scoped data source within a `check` block.

A `check` block can optionally contain a nested (a.k.a scoped) data source. This `data` block behaves like an external [data source](/terraform/language/data-sources), except you can not reference it outside its enclosing `check` block. Additionally, if a scoped data source's provider raises any errors, they are masked as warnings and do not prevent Terraform from continuing operation execution.

You can use a scoped data source to validate the status of a piece of infrastructure outside of the usual Terraform resource lifecycle. [In the above example](#checks-syntax), if the `terraform_io` data source fails to load, you receive a warning instead of a blocking error, which would occur if you declared this data source outside of a `check` block.


#### Meta-Arguments

Scoped data sources support the `depends_on` and `provider` [meta-arguments](/terraform/language/resources/syntax#meta-arguments). Scoped data sources do not support the `count` or`for_each` meta-arguments.

##### `depends_on`

The `depends_on` meta argument can be particularly powerful when used within scoped data sources.

The [previous example](#checks-syntax) would fail during any initial planning, as the configuration hasn't been applied so the website simply would not exist. As written, this would be expected behaviour but is not particularly useful and is potentially noisy as other genuine errors in the configuration could be obscured by the warning message.

An addition of the `depends_on` attribute, linking the scoped data source to the highest-levelled piece of infrastructure such as a load balancer, would mean that during any initial planning the check would instead report as `known after apply`. In addition, it would not produce any unnecessary or noisy warnings. Going forward, the check would execute again for both plans and applies providing the required validation.

One caveat to the `depends_on` attribute is that any changes to the dependencies would again cause the check block to report as `known after apply`, essentially meaning the check block would not execute during that planning stage. Depending on your use case this behavior could be acceptable or problematic.

### Assertions

Check blocks validate your custom assertions using `assert` blocks. Each `check` block must have at least one, but potentially many, `assert` blocks. Each `assert` block has a [`condition` attribute](/terraform/language/expressions/custom-conditions#condition-expressions) and an [`error_message` attribute](/terraform/language/expressions/custom-conditions#error-messages).

Unlike other [custom conditions](/terraform/language/expressions/custom-conditions), assertions do not affect Terraform's execution of an operation. A failed assertion reports a warning without halting the ongoing operation. This contrasts with other custom conditions, such as a postcondition, where Terraform produces an error immediately, halting the operation and blocking the application or planning of future resources.

Condition arguments within `assert` blocks can refer to scoped data sources within the enclosing `check` block and any variables, resources, data sources, or module outputs within the current module.

[Learn more about assertions](/terraform/language/expressions/custom-conditions#check-assertions).

### Meta-Arguments

Check blocks do not currently support [meta-arguments](/terraform/language/resources/syntax#meta-arguments). We are still collecting feedback on this feature, so if your use case would benefit from check blocks supporting meta-arguments, please [let us know](https://github.com/hashicorp/terraform/issues/new).

## Continuous Validation in Terraform Cloud

Terraform Cloud can automatically validate whether checks in a workspaceâ€™s configuration continue to pass after Terraform provisions new infrastructure. See [Continuous Validation](/terraform/cloud-docs/workspaces/health#continuous-validation) for details.

## Choosing Checks or other Custom Conditions

Check blocks offer the most flexible validation solution within Terraform. As you can reference outputs, variables, resources and data sources within check assertions, they can be used to model all the alternate [Custom Conditions](/terraform/language/expressions/custom-conditions). However, that does not mean you should replace all your custom conditions with check blocks.

As discussed, the major behavioral difference between [check block assertions](#assertions) and other custom conditions is that they do not affect Terraform's execution of an operation. It is this behaviour you should think about when deciding which validation to apply.

### Outputs and Variables

[Output postconditions](/terraform/language/expressions/custom-conditions#outputs) and [variable validations](/terraform/language/expressions/custom-conditions#input-variable-validation) both make assertions around inputs and outputs.

In these cases it is often desirable that Terraform should block further execution. For example, it is not useful to warn that an input variable was invalid after an entire Terraform configuration has been applied based on that invalid value. This is the behaviour a check block would apply if an assertion was made against a variable. A validation block against the variable itself would alert before any configuration was applied that the provided input was invalid, and then not create infrastructure based on a flawed premise.

### Resource preconditions and postconditions

The boundary between resource and data source [preconditions and postconditions](/terraform/language/expressions/custom-conditions#preconditions-and-postconditions) and check blocks is more nuanced.

Preconditions are unique amongst the custom conditions in that they execute before a resource change is applied or planned, rather than after. This is discussed in detail in [Choosing Between Preconditions and Postconditions](/terraform/language/expressions/custom-conditions#choosing-between-preconditions-and-postconditions) and the same advice applies when choosing between a precondition and a check block.

Postconditions, however, can often be used interchangeably with check blocks to validate resources and data sources.

For example, you can [rewrite the above `check` block example](#checks-syntax) to use a postcondition instead. The below code uses a `postcondition` block to validate that the Terraform website returns the expected status code of `200`.

```hcl
data "http" "terraform_io" {
  url = "https://www.terraform.io"

  lifecycle {
    postcondition {
        condition = self.status_code == 200
        error_message = "${self.url} returned an unhealthy status code"
    }
  }
}
```

Both of our `check` and `postcondition` block examples validate that the Terraform website returns a `200` status code during a plan or an apply operation. The difference between the two blocks is how each handles failure.

If a `postcondition` block fails, it _blocks_ Terraform from continuing execution of the current operation. If a `check` block fails, it _does not_ block Terraform's execution of an operation.

If the above example's postcondition fails, it is impossible to recover from. Terraform blocks any future plan or apply operations if your postcondition is unsatisfied during the planning stage. This problem occurs because the postcondition does not directly depend on Terraform configuration, but instead on the complex interactions between multiple resources.

We recommend using check blocks to validate the status of infrastructure as a whole. We only recommend using postconditions when you want a guarantee on a single resource based on that resource's configuration.
